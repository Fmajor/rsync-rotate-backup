#!/bin/env python
import os
import time
import subprocess
import yaml
import os
import random
import sys
import argparse
import glob
import humanize
import fnmatch
import copy
import calendar
import json
from pprint import pprint
from prettytable import PrettyTable
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from dateutil.parser import parser as time_parser

## config and setup
DESCRIPTION='''Backup data in a rotation mode.'''

TIMEFORMAT = "%Y-%m-%dT%H:%M:%S"

DEFAULT_CONFIG='''## rsync-rotate-backup config file
interval: 1s # min interval of two auto rotate backup
max-age: 2y # max age of one auto rotate backup

# how long will backup stay at xx level. if 0, will stay forever
max-year: 5
max-month: 12
max-week: 6
max-day: 7
max-hour: 24
max-minute: 60

# the interval in xx level. if 0, do not delete old backups at this level. Should less than max-xx.
interval-year: 1
interval-month: 1
interval-week: 1
interval-day: 1
interval-hour: 3
interval-minute: 30


# the start value of each xx
start-month:     1 # 1~12
start-day-month: 1 # -27~28
start-day-week:  1 # 1~7
start-hour:      0 # 0~59
start-minute:    0 # 0~59
start-second:    0 # 0~59
'''
def check_config(*, config=None):
  c = config
  # check max and intervals
  for each in ['minute', 'hour', 'day', 'week', 'month', 'year']:
    if c['interval-{}'.format(each)] > c['max-{}'.format(each)]:
      raise Exception('interval-{each} should not be larger than max-{each}'.format(each=each))
    if not (c['interval-{}'.format(each)]>=0):
      raise Exception('interval-{each} should be larger than 0'.format(each=each))
    if not (c['max-{}'.format(each)]>=0):
      raise Exception('max-{each} should be larger than 0'.format(each=each))
  name = 'month'
  if not (c['start-{}'.format(name)]>=1 and c['start-{}'.format(name)]<=12):
    raise Exception('range of start-{} not correct!'.format(name))
  name = 'day-month'
  if not (c['start-{}'.format(name)]>=-27 and c['start-{}'.format(name)]<=28):
    raise Exception('range of start-{} not correct!'.format(name))
  name = 'day-week'
  if not (c['start-{}'.format(name)]>=1 and c['start-{}'.format(name)]<=7):
    raise Exception('range of start-{} not correct!'.format(name))
  name = 'hour'
  if not (c['start-{}'.format(name)]>=0 and c['start-{}'.format(name)]<=59):
    raise Exception('range of start-{} not correct!'.format(name))
  name = 'minute'
  if not (c['start-{}'.format(name)]>=0 and c['start-{}'.format(name)]<=59):
    raise Exception('range of start-{} not correct!'.format(name))
  name = 'second'
  if not (c['start-{}'.format(name)]>=0 and c['start-{}'.format(name)]<=59):
    raise Exception('range of start-{} not correct!'.format(name))

parser = argparse.ArgumentParser(
  description=DESCRIPTION,
  formatter_class=argparse.RawTextHelpFormatter,
)

subparsers = parser.add_subparsers(help='', dest='subparser_name')

init_parser = subparsers.add_parser('init', help='init a backup directory')
backup_parser = subparsers.add_parser('backup', help='make a new backup')
init_parser.add_argument('dest', type=str, help='''init a backup directory''', nargs=1)
init_parser.add_argument(
  '--force',
  action="store_const", const=True, default=False,
  help='''replace exists config.yml with the default configuration''',
  )
backup_parser.add_argument('src', type=str, help='srouce directory to be backuped', nargs=1)
backup_parser.add_argument('dest', type=str, help='''root directory to put the backups
should be a empty folder, a folder init from --init command or a non-exists folder''', nargs=1)

unitNameMap = {
  'minute': 'm',
  'hour': 'h',
  'day': 'd',
  'week': 'w',
  'month': 'M',
  'year': 'y',
}
def process_delta_time(s):
  'e.g., 1h => 1h deltatime'
  unit = s[-1]
  value = float(s[:-1])
  if unit not in ['s', 'm', 'h', 'd', 'M', 'y', 'w']:
    raise Exception('time interval must have the write unit in smhdMyw, yours are {}'.format(s))
  if unit == 's':
    return relativedelta(seconds=value)
  elif unit == 'm':
    return relativedelta(minutes=value)
  elif unit == 'h':
    return relativedelta(hours=value)
  elif unit == 'd':
    return relativedelta(days=value)
  elif unit == 'M':
    return relativedelta(months=value)
  elif unit == 'y':
    return relativedelta(years=value)
  elif unit == 'w':
    return relativedelta(weeks=value)
def delete_by_max_age(to_reserve, to_delete, now=None, config=None):
  this_to_reserve = []
  this_to_delete = []
  oldest_time = now - process_delta_time(config['max-age'])
  for eachfile in to_reserve:
    if eachfile['timestamp'] <= oldest_time:
      eachfile['reason'] = 'older than {}'.format(config['max-age'])
      this_to_delete.append(eachfile)
    else:
      this_to_reserve.append(eachfile)
  return this_to_reserve, this_to_delete
def delete_by_min_interval(to_reserve, to_delete, now=None, config=None):
  this_to_reserve = []
  min_delta = process_delta_time(config['interval'])
  if len(to_reserve) <= 1:
    return to_reserve, to_delete
  this_to_reserve.append(to_reserve[0])
  thisindex = 0
  nextindex = 1
  while nextindex < len(to_reserve):
    thisfile = to_reserve[thisindex]
    nextfile = to_reserve[nextindex]
    if thisfile['timestamp'] - min_delta < nextfile['timestamp']: # should delete nextfile
      nextfile['reason'] = 'interval: {}, too near with {}'.format(config['interval'], thisfile['timestampStr'])
      to_delete.append(nextfile)
      nextindex += 1
    else: # should reserve nextfile and set it to thisindex
      this_to_reserve.append(nextfile)
      thisindex = nextindex
      nextindex += 1
  return this_to_reserve, to_delete
def delete_in_levels(to_reserve, to_delete, config=None):
  this_to_reserve = copy.deepcopy(to_reserve)
  lg = last_good_file = to_reserve[0]['timestamp']
  for level in ['minute', 'hour', 'day', 'week', 'month', 'year']:
    max_length = str(config.get('max-{}'.format(level), 0))
    interval   = str(config.get('interval-{}'.format(level), 0))
    if max_length==0 or interval ==0:
      continue
    max_length = process_delta_time(str(max_length) + unitNameMap[level])
    interval = process_delta_time(str(interval) + unitNameMap[level])
    if level == 'minute':
      true_start = datetime(
        year=lg.year, month=lg.month, day=lg.day, hour=lg.hour,
        minute=lg.minute, second=config.get('start-second')
      )
    elif level == 'hour':
      true_start = datetime(
        year=lg.year, month=lg.month, day=lg.day, hour=lg.hour,
        minute=config.get('start-minute'), second=config.get('start-second')
      )
    elif level == 'day':
      true_start = datetime(
        year=lg.year, month=lg.month, day=lg.day, hour=config.get('start-hour'),
        minute=config.get('start-minute'), second=config.get('start-second')
      )
    elif level == 'week':
      onDay = lambda date, day: date + timedelta(days=(day-date.weekday()+7)%7) - timedelta(days=7)
      true_start = datetime(
        year=lg.year, month=lg.month,
        day=lg.day, hour=config.get('start-hour'),
        minute=config.get('start-minute'), second=config.get('start-second')
      )
      true_start = onDay(true_start, config.get('start-weekday',1) - 1)
    elif level == 'month':
      day = config.get('start-day-month', 0)
      if day < 0:
        day = calendar.monthrange(lg.year, lg.month)[1] + day
      true_start = datetime(
        year=lg.year, month=lg.month,
        day=day, hour=config.get('start-hour'),
        minute=config.get('start-minute'), second=config.get('start-second')
      )
    elif level == 'year':
      true_start = datetime(
        year=lg.year, month=config.get('start-month'),
        day=config.get('start-day-month'), hour=config.get('start-hour'),
        minute=config.get('start-minute'), second=config.get('start-second')
      )

    #  |one interval|one interval|one interval|one interval|....|one interval|
    #           lg [true_start,  o,           o,           o,...o,    true_end, max_end], other...
    while lg < true_start:
      true_start = true_start - interval
    max_end = true_start - max_length
    end = true_start
    intervals = [(true_start, lg)]
    # true start is the latest
    while end - interval >= max_end:
      right = end
      end = end - interval
      left = end
      true_end = end # the oldest
      intervals.append((left, right))
    # not processed in this level
    this_level_to_reserve = list(filter(lambda _:_['timestamp']>lg or _['timestamp']<=true_end, this_to_reserve))
    to_process = list(filter(lambda _:_['timestamp']<=lg and _['timestamp']>true_end, this_to_reserve))
    ##print('==========================================')
    ##print(lg)
    ##print(true_start, true_end, interval)
    ##print('  to_process_length: {}, reserve_length:{}, total_length:{}'.format(len(to_process), len(this_level_to_reserve), len(this_to_reserve)))
    processed_reserve = []
    # in this_level_to_process
    for left, right in intervals:
      # in each interval, only have one
      this_files = list(filter(lambda _:_['timestamp']>left and _['timestamp']<=right, to_process))
      if len(this_files):
        this_files.sort(key=lambda _:_['timestamp'])
        r = this_files[-1]
        d = this_files[:-1]
        processed_reserve.append(r)
        for each in d:
          each['reason'] = 'level: {}, {} ~ {} only use {}'.format(
            level,
            left.strftime(TIMEFORMAT),
            right.strftime(TIMEFORMAT),
            r['timestamp'].strftime(TIMEFORMAT),
          )
          to_delete.append(each)
    this_level_to_reserve.extend(processed_reserve)
    if len(processed_reserve):
      processed_reserve.sort(key = lambda _:_['timestamp'])
      lg = processed_reserve[0]['timestamp']
    ##for each in reversed(processed_reserve): print(each['timestampStr'])
    ##print('  processed_reverse_length: {}, total_length: {}'.format(len(processed_reserve), len(this_level_to_reserve)))
    this_to_reserve = this_level_to_reserve
  this_to_reserve.sort(key=lambda _:_['timestamp'])
  this_to_reserve.reverse()
  to_delete.sort(key=lambda _:_['timestamp'])
  to_delete.reverse()
  return this_to_reserve, to_delete
def get_clean_list(output, config=None, now=None):
  ## get old backups
  autoclean = {}
  rootpath = os.path.join(output, 'backup', 'auto')
  for root, dirs, files in os.walk(rootpath):
    relpath = os.path.relpath(root, rootpath)
    if len(files):
      fileinfo = []
      for eachfile in files:
        if not eachfile.endswith('.gz'):
          continue
        timestampStr = eachfile.split('|')[-1].split('_')[0]
        timestamp = datetime.strptime(timestampStr, TIMEFORMAT)
        fileinfo.append({
          'filename': os.path.join(root, eachfile),
          'timestampStr': timestampStr,
          'timestamp': timestamp,
        })

      autoclean[relpath] = {
        'raw': fileinfo,
        'to_delete': None,
        'to_reserve': None,
      }
  for eachpath in autoclean:
    todo = autoclean[eachpath]
    raw = todo['raw']
    raw.sort(key=lambda _:_['timestamp'])
    raw.reverse()
    to_delete = []
    to_reserve = copy.deepcopy(raw)
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    to_reserve, to_delete = delete_in_levels(to_reserve, to_delete, config=config)
    autoclean[eachpath]['to_delete'] = to_delete
    autoclean[eachpath]['to_reserve'] = to_reserve
  return autoclean
def do_unittest(config=None):
  now = datetime(year=2019, month=9, day=9, hour=13, minute=37, second=24)
  def gen_time(N, interval, fileinfo):
    for i in range(N):
      timestamp = now - i * interval
      timestampStr = timestamp.strftime(TIMEFORMAT)
      fileinfo.append({
        'filename': timestampStr,
        'timestampStr': timestampStr,
        'timestamp': timestamp,
      })
  def ppp(files):
    for each in files:
      print(each['filename'])
  fileinfo = []
  gen_time(120, process_delta_time('1m'), fileinfo)
  gen_time(48,  process_delta_time('1h'), fileinfo)
  gen_time(60,  process_delta_time('1d'), fileinfo)
  gen_time(12,   process_delta_time('1w'), fileinfo)
  gen_time(24,  process_delta_time('1M'), fileinfo)
  gen_time(10,  process_delta_time('1y'), fileinfo)
  fileinfo_set = {_['filename']:_ for _ in fileinfo}
  fileinfo = list(fileinfo_set.values())
  fileinfo.sort(key=lambda _:_['timestamp'])
  fileinfo.reverse()
  N = len(fileinfo)

  if 'test max-age':
    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '1m'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 1 and len(to_delete) == N-1

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '10m'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 10 and len(to_delete) == N-10

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '90m'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 90 and len(to_delete) == N-90

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '2h'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 120 and len(to_delete) == N-120

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '3h'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 121 and len(to_delete) == N-121

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '5h'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 123 and len(to_delete) == N-123

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '1d'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 142 and len(to_delete) == N-142

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '2d'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 166 and len(to_delete) == N-166

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '3d'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 167 and len(to_delete) == N-167

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '7d'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 171 and len(to_delete) == N-171

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-age'] = '14d'
    to_reserve, to_delete = delete_by_max_age(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 178 and len(to_delete) == N-178
  if 'test interval':
    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '1m'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N and len(to_delete) == 0

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '2m'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 60 and len(to_delete) == 60

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '3m'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 80 and len(to_delete) == 80

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '10m'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 108 and len(to_delete) == 108

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '1h'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 118 and len(to_delete) == 118

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '2h'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 142 and len(to_delete) == 142

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '3h'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 150 and len(to_delete) == 150

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '8h'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 160 and len(to_delete) == 160

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '1d'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 164 and len(to_delete) == 164

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '2d'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 195 and len(to_delete) == 195

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '3d'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 205 and len(to_delete) == 205

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '1w'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 216 and len(to_delete) == 216

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '2w'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 222 and len(to_delete) == 222

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '3w'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 224 and len(to_delete) == 224

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '1M'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 225 and len(to_delete) == 225

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '3M'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 241 and len(to_delete) == 241

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '1y'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == N - 247 and len(to_delete) == 247

    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['interval'] = '3y'
    to_reserve, to_delete = delete_by_min_interval(to_reserve, to_delete, now=now, config=config)
    assert len(to_reserve) == 4 and len(to_delete) == N - 4
  if 'test level':
    to_delete = []; to_reserve = copy.deepcopy(fileinfo);
    config['max-year']  = 5
    config['max-month']  = 12
    config['max-week']   = 8
    config['max-day']    = 7
    config['max-hour']   = 24
    config['max-minute'] = 60
    config['interval-year']   = 2
    config['interval-month']  = 2
    config['interval-week']   = 2
    config['interval-day']    = 2
    config['interval-hour']   = 3
    config['interval-minute'] = 20
    config['start-month']     = 1 # 1~12
    config['start-day-month'] = 1 # 1~28, can be negitave
    config['start-day-week']  = 0 # 1~7
    config['start-hour']      = 0 # 0~59
    config['start-minute']    = 0 # 0~59
    config['start-second']    = 0 # 0~59
    to_reserve, to_delete = delete_in_levels(to_reserve, to_delete, config=config)


  print(len(to_delete))
  import ipdb
  ipdb.set_trace()
def print_config(config):
  print('  interval: {interval}, max-age:{max-age}'.format(**config))
  toPrints = [
    'max-year',
    'max-month',
    'max-week',
    'max-day',
    'max-hour',
    'max-minute',
  ]
  p = ['{key}:{value}'.format(key=_,value=config[_]) for _ in toPrints]
  print('  '+', '.join(p))
  toPrints = [
    'interval-year',
    'interval-month',
    'interval-week',
    'interval-day',
    'interval-hour',
    'interval-minute',
  ]
  p = ['{key}:{value}'.format(key=_,value=config[_]) for _ in toPrints]
  print('  '+', '.join(p))
  toPrints = [
    'start-month',
    'start-day-month',
    'start-day-week',
    'start-hour',
    'start-minute',
    'start-second',
  ]
  p = ['{key}:{value}'.format(key=_,value=config[_]) for _ in toPrints]
  print('  '+', '.join(p))

def do_backup(*, config=None, now=None):
  dest = config['dest']
  src = config['src']
  logfile = os.path.join(dest, 'log.log')
  timestamp = now.strftime(TIMEFORMAT)

  backup_path = os.path.join( dest, timestamp)
  os.mkdir(backup_path)
  cmd = '''mysqldump {backup_login} {backup_args} {backup_obj} | gzip > "{filename}"'''.format(**locals())
  print(pcmd)
  time0 = time.time()
  print('start to backup with: {backup_obj}'.format(**locals()))
  ps = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  stdout = ps.stdout.read().decode()
  stderr = ps.stderr.read().decode()
  if stdout or stderr:
    print('stdout:', stdout)
    print('stderr:', stderr)
    print('have error!')
    if os.path.exists(filename):
      os.remove(filename)
      print('delete file:\n  ', filename)
      dirname = os.path.dirname(filename)
      if not os.listdir(dirname):
        os.rmdir(dirname)
        print('delete empty folder:\n  ', dirname)
    sys.exit(1)
  else:
    print('finish backup in {:.1f}s'.format(time.time() - time0))
  print('=======log=======')
  ## clean old backups
  cleanList = get_clean_list(output, config=config, now=now)

  ## write to log
  LOG_TEMPLAGE="{timestamp} {command} "
  log = LOG_TEMPLAGE.format(
    timestamp=timestamp,
    command=config['command'],
  ) + "{name} {filename}".format(
    filename=os.path.basename(filename),
    name='name:'+c.get('name') if c.get('name') else 'auto',
  )
  logs = [log]
  for eachdir in cleanList:
    if len(cleanList[eachdir]['to_delete']):
      logs.append('  clean {}'.format(eachdir))
      for eachfile in cleanList[eachdir]['to_delete']:
        os.remove(eachfile['filename'])
        logs.append('    delete '+eachfile['filename'])
        logs.append('      '+eachfile['reason'])

  log = '\n'.join(logs)
  if os.path.exists(logfile):
    with open(logfile, 'a') as f:
      f.write('\n' + log)
  else:
    with open(logfile, 'a') as f:
      f.write(log)
  print(log)
def find_files(directory, pattern):
  for root, dirs, files in os.walk(directory):
    for basename in files:
      if fnmatch.fnmatch(basename, pattern):
        filename = os.path.join(root, basename)
        yield filename

if __name__ == '__main__':
  now = datetime.now()
  args = parser.parse_args()
  if not args.subparser_name:
    parser.print_help()
    sys.exit(0)
  dest = args.dest[0]
  os.makedirs(dest, exist_ok=True)
  configFile = os.path.join(dest, 'config.yml')
  if args.subparser_name == 'init': # do init
    if os.path.exists(configFile):
      if not args.force:
        raise Exception('config file {} already exists. Use --force to replace it'.format(configFile))
      else:
        print('replace config file {} with the default one'.format(configFile))
    else:
      print('generate new config file {}'.format(configFile))
    # gen config file to configFile
    with open(configFile, 'w') as f:
      f.write(DEFAULT_CONFIG)
    sys.exit(0)
  elif args.subparser_name == 'backup': # do init
    dest = args.src[0]
    if not os.path.exists(configFile):
      print('generate new config file {} and do backup'.format(configFile))
      with open(configFile, 'w') as f:
        f.write(DEFAULT_CONFIG)
    else:
      print('use config file {} and do backup'.format(configFile))
    with open(configFile, 'r') as f:
      config = yaml.safe_load(f)
  else:
    raise Exception('should not be here')

  # check config file
  try:
    check_config(config=config)
  except Exception as e:
    raise Exception('Error in configfile: {}\n{}'.format(configFile, str(e)))
  #do_unittest(config=config)
  config['src'] = src
  config['dest'] = dest
  print(timestamp)
  print_config(config)
  do_backup(config=config, now=now)

